
CONTRAINTES:
* dernière idée en date :
  - modifier BindingResult de sorte que Ok et Err ne soient pas complètement séparés :
  on pourrait avoir un résultat ET une erreur
    type BindingResult res
        = Ok res
        | Err BindingErr
        | Irrelevant
  deviendrait :
    type alias BindingResult res = (Maybe res, Maybe BindingErr)

  On a donc plusieurs cas possibles :
   - pas de résultat, pas d'erreur --> équivalent de Irrelevant
   - un résultat, pas d'erreur --> équivalent de Ok
   - pas de résultat, une erreur --> équivalent de Err
   - un résultat, une erreur --> bien on a qqch, mais on a aussi une info supplémentaire,
                                 que même si on a un résultat, qqch ne tourne pas rond

  BindingErr devient alors plus que juste une binding error, mais plutôt une model/constraint/binding error.

* Mais est-ce-que le bon concept est vraiment celui d'erreur ?
  N'aurait-on pas juste une "annotation" du résultat ?

  type alias BindingResult res = (Maybe res, Maybe Annotation)

* Mmmh pas sûr. Comment gérer tout type d'annotation ? Il faut un système d'extensions, ca devient très lourd...
  Ne cherchons pas à trop généraliser.
* Partons de use cases seulement.
  On veut gérer les erreurs donc on a besoin que de string.
  Mmmh on veut aussi gérer des quickfix par exemple. Donc on a alors aussi besoin d'actions.
  On peut éventuellement vouloir des actions contextuelles genre refactorings.
  Ok donc il faut effectivement un système plus général.
  ICI: déveloper cette réflexion

LIST BINDING

0. En fait il faut clairement une notion de métamodèle.
  Comment caractériser ca ?
  - déjà les modèles seront toujours fait de structures et de listes. Comment modéliser les références ?
  Peut-être qu'on peut tout aplatir ?
1. SelectableList.Converter ne convertit pas de NewItemWidget vers ItemWidget, mais de NewItemWidget vers model
2. listBinding.addItem prend en paramètre une valeur
  -> va probablement être chiant de transmettre une valeur à travers le port...
  Mais bon probablement une nécessité aussi.
3. listBinding.itemAdded prend en paramètre une valeur
  La valeur n'est pas utilisée pour le display de l'itemWidget, mais uniquement pour le binding: pour pouvoir filtrer.
  Pour l'affichage de l'itemWidget, ce dernier va simplement être automatiquement inscrit aux updates.

COURANT:
- comment implémenter les contraintes ? comme des composants séparés avec double-souscriptions ?
- comment faire avaler aux widgets des contraintes ?
- comment rendre la définition de contrainte la plus facile possible ?
- il faut pouvoir définir des contraintes de facon délocalisée :
  un métamodèle peut se voir ajouter des contraintes depuis n'importe quel élément extérieur
- une factory est nécessaire pour construire la base
- mais d'abord faire la factory à la main

META-REMARQUE ARCHITECTURE

Remarques sur l'evolution d'une architecture :
la question "où donner l'information de chemin?" a trouvé plusieurs solutions successives :
- passé en tant qu'argument au binding
- passé en tant qu'argument au widget directement avec le binding devenant une fonction qui prend ce chemin en argument
- passé en tant qu'argument à la continuation de la souscription



où sont transmis les get/set?
1. au widget creator
  params -> (init: () -> model, update: model -> msg -> model)
  les paramètres sont figés à la création

2. à la fonction d'update
  (init: () -> model, update: model -> params -> msg -> model)
  les paramètres peuvent varier en fonction du modèle

Facile à dire a posteriori. La dificulté c'est savoir quelle est la question à poser pour décrouvrir ce qui est décisif.
