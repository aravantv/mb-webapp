<!DOCTYPE HTML>
<html>

<head>
    <meta charset="UTF-8">
    <title>Elm â€¢ Model-based Web App</title>
    <script type="text/javascript" src="main.js"></script>
    <link rel="stylesheet" href="style.css">
</head>

<body>
</body>

<script type="text/javascript">
    /* Storage is done as follows:
     * - every data gets a unique ID
     * - the local storage has an entry for every such ID
     * - every atomic data (string, boolean, number) is represented in the local storage
     *   by a map entry from its ID to its value in the local storage
     * - every array is represented by a map entry from its ID to an array of IDs:
     *   the IDs of all items in the array
     * - every object is represented by a map entry from its ID to an object where every key
     *   is a key in the original object and the associated data is the ID of the corresponding value.
     *
     * An object represented in this form is called "shallow".
     * The operation of following the IDs and replacing them by their actual values iteratively
     * is called the "reconstitution" of the object.
    **/

    // Just retrieves the object of [id] as a Json object
    function getShallowObject(id) {
      var serializedShallowObject = localStorage.getItem(id)
      return serializedShallowObject ? JSON.parse(serializedShallowObject) : 'ID NOT FOUND - please report'
    }

    // Follows the references to reconstitue a complete object.
    // If part of the object is already known, it can be provided as the second parameter.
    function reconstituteObject(shallowObject, knownID, knownValue) {
      if (typeof shallowObject === 'string') {
        return shallowObject
      } else if (typeof shallowObject === 'number') {
        return shallowObject
      } else if (typeof shallowObject === 'boolean') {
        return shallowObject
      } else if (typeof shallowObject === 'object') {
        if (Array.isArray(shallowObject)) {
          var result = []
          shallowObject.forEach(function(id) {
            result.push(id === knownID ? knownValue : reconstituteObject(getShallowObject(id)))
          })
          return result
        } else {
          Object.keys(shallowObject).forEach(function(key) {
            var id = shallowObject[key]
            shallowObject[key] = id === knownID ? knownValue : reconstituteObject(getShallowObject(id))
          });
          return shallowObject
        }
      }
    }

    /* Listeners need to know when an object is modified in a deep manner:
     * i.e., it should be notified not only when the shallow object is modified,
     * but also when one of its children is.
     * Furthermore, when such a deep change occurs, the listener often needs to know the path
     * to the descendant which was modified, therefore we need to also compute this path.
     *
     * To fulfill these requirements, we define the [parentIDs] structure, which keeps track,
     * for every ID, of all its parents which are transitively subscribed to: this way, as soon
     * as an object is modified, we inform its direct listeners, and then transitively inform
     * its parents which are to be notified. On the way, we also compute the corresponding path
     * to inform the parent listener adequately.
     * All in all, [parentIDs] is an object mapping IDs of (transitively) tracked objects to
     * another object mapping IDs of the tracked parents of the object to the path of the object
     * within the corresponding parent.
     * We could as well use an object mapping IDs to lists of pairs parentID-pathToParent,
     * but using an object makes [shiftParentChildrenIDs] easier to implement (and more efficient).
    **/
    var parentIDs = {}

    // True if the corresponding ID is (directly or transitively) tracked.
    function isListened(id) {
      return parentIDs[id] != null
    }

    // Adds [parentID] (and the corresponding [pathToParent]) to the list of parents of [id] which are tracked.
    function addParentID(id, parentID, pathToParent) {
      if (!parentIDs[id]) {
        parentIDs[id] = {}
      }
      if (parentID && parentIDs[id].indexOf(parentID) > -1) {
        parentIDs[id][parentID] = pathToParent
      }
    }

    // Called in the case the object at [id] just got subscribed to.
    // We then go down the structure of [id] recursively to update [parentIDs] accordingly:
    // we add [parentID] (along with [pathToParent]) to the list of parent IDs associated with [id],
    // and iterate the operation for the children of [id].
    // Note that [parentID] can be null: this happens only for the first call, indeed,
    // the first [id] to be updated is the one being subscribed to and therefore is the root of the process.
    // All recursive calls, on the other hand, provide a non-null [parentID].
    function updateParentIDs(id, parentID, pathToParent) {
      // must be computed before the call to [addParentID]
      var alreadyPresent = parentID ? false : parentIDs[id].indexOf(parentID) == -1

      if (parentID) {
        addParentID(id, parentID, pathToParent)
      } else {
        parentIDs[id] = {}
      }

      // The following condition is there to prevent potential infinite loops
      if (!(parentID && alreadyPresent)) {
        var valueAtId = JSON.parse(localStorage.getItem(id))
        if (typeof obj === 'object') {
          if (Array.isArray(valueAtId)) {
            valueAtId.forEach(function (subId, i) {
              updateParentIDs(subId, id, i)
            })
          } else {
            Object.keys(obj).forEach(function (key) {
              updateParentIDs(obj[key], id, key)
            }
          }
        }
      }
    }

    // Creates a new unique ID. To be done better in the future.
    function createNewID() {
      return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8)
        return v.toString(16)
      });
    }

    // Turn a full Json object [obj] into a shallow object:
    // - repaces children by new unique IDs
    // - maps these IDs to the (recursively) flattened objects in the local storage
    // [parentID] *can* be provided to also update the listening [parentIDs] of the object on the fly.
    function flattenObject(obj, parentID) {
      if (typeof obj === 'string') {
        return obj
      } else if (typeof obj === 'number') {
        return obj
      } else if (typeof obj === 'boolean') {
        return obj
      } else if (typeof obj === 'object') {
        if (Array.isArray(obj)) {
          var result = []
          obj.forEach(function(x, i) {
            var xId = createNewID()
            var shallowX = flattenObject(x, parentID ? xId : null)
            if (parentID) {
              addParentID(xId, parentID, i)
            }
            localStorage.setItem(xId, JSON.stringify(shallowX))
            result.push(xId)
          })
        } else {
          var result = {}
          Object.keys(obj).forEach(function(key) {
            var keyId = createNewID()
            var shallowObjKey = flattenObject(obj[key], parentID ? keyId : null)
            if (parentID) {
              addParentID(keyId, parentID, key)
            }
            localStorage.setItem(keyId, JSON.stringify(shallowObjKey))
            result[key] = keyId
          })
          return result
        }
      }
    }

    var mbwebapp = Elm.Main.fullscreen()

    var ADDED = 1
    var REMOVED = -1
    var MODIFIED = 0

    mbwebapp.ports.subscribeCmdPort.subscribe(function(id) {
      updateParentIDs(id, null)
    })

    mbwebapp.ports.askDataCmdPort.subscribe(function (id) {
      var shallowObj = getShallowObject(id)
      mbwebapp.ports.getDataSubPort.send([id, shallowObj, reconstituteObject(shallowObj), []])
    })

    // Informs transitively all the parents of [id] which subscribed to changes.
    // Prevents possibly cyclic data structures (don't see any use case where it would happen but let's be protective).
    function informParents(id, knownValue, eventType) {
      var alreadySeenIDs = []
      informParentsWithoutCycle(id, knownValue, [])
      additionalInfo = eventType === ADDED ? knownValue : null
      function informParentsWithoutCycle(id, knownValue, currentPath) {
        if (parentIDs[id] && alreadySeenIDs.indexOf(id) === -1) {
          alreadySeenIDs.push(id)
          var value = knownValue ? knownValue : reconstituteObject(getShallowObject(id))
          var idParentIDs = parentIDs[id]
          Object.keys(idParentIDs).forEach(function(parentID) {
            var parentValue = reconstituteObject(parentID, id, value)
            var shallowParentValue = getShallowObject(parentID)
            newPath = currentPath.slice()
            newPath.push(idParentIDs[parentID])
            if (eventType === MODIFIED) {
              mbwebapp.ports.getDataSubPort.send([parentID, shallowParentValue, parentValue, newPath])
            }
            if (eventType === ADDED) {
              mbwebapp.ports.itemAddedSubPort.send([parentID, newPath, additionalInfo])
            }
            if (eventType === REMOVED) {
              mbwebapp.ports.itemRemovedSubPort.send([parentID, newPath])
            }
            informParentsWithoutCycle(parentID, parentValue, newPath)
          })
        }
      }
    }

    mbwebapp.ports.setDataCmdPort.subscribe(function (args) {
        var id = args[0]
        var value = args[1]
        var shallowValue = flattenObject(value, isListened(id) ? id : null)
        localStorage.setItem(id, JSON.stringify(shallowValue))
        mbwebapp.ports.getDataSubPort.send([id, shallowValue, value, []])
        informParents(id, value, MODIFIED)
    })

    // Shifts all the *paths* stored in [parentIDs] for every child of [parentID]
    // starting at a given [startIndex] and by a given [shift] value.
    // Needed to adapt the paths in case of addition/removal in the middle of a list.
    // Typically, [shift] is 1 in case an element was added just before [startIndex].
    // It is -1 if this element was removed.
    function shiftParentChildrenIDs(parentID, startIndex, shift) {
      parentID.forEach(function(id, i) {
        if (i >= startIndex) {
          parentIDs[id][parentID] += shift
        }
      })
    }


    // NEXT: all ports are developed with indexes in mind, make them use paths

    mbwebapp.ports.addItemCmdPort.subscribe(function (args) {
        var id = args[0]
        var index = args[1]
        var valueAtId = JSON.parse(localStorage.getItem(id))
        if (typeof valueAtId !== 'object' || !(Array.isArray(valueAtId))) {
          console.log("ERROR: Request to add an item to a non-array data (id: " + id + ")")
        } else {
          var value = args[2]
          var valueId = createNewID()
          var shallowValue = flattenObject(value, isListened(id) ? valueId : null)
          addParentID(valueId, id, index)
          shiftParentChildrenIDs(id, index + 1, 1)
          localStorage.setItem(valueId, JSON.stringify(shallowValue))
          valueAtId.splice(index, 0, valueId)
          localStorage.setItem(id, JSON.stringify(valueAtId))
          mbwebapp.ports.itemAddedSubPort.send([id, [index], value])
          informParents(valueId, value, ADDED)
        }
    })

    mbwebapp.ports.removeItemCmdPort.subscribe(function (args) {
      var id = args[0]
      var index = args[1]
      var valueAtId = JSON.parse(localStorage.getItem(id))
      if (typeof valueAtId !== 'object' || !(Array.isArray(valueAtId))) {
        console.log("ERROR: Request to add an item to a non-array data (id: " + id + ")")
      } else {
        valueAtId.splice(index,1)
        localStorage.setItem(id, JSON.stringify(valueAtId))
        mbwebapp.ports.itemRemovedSubPort.send([id, [index]])
        shiftParentChildrenIDs(id, index, -1)
        informParents(id, null, REMOVED)
      }
    })
</script>

</html>
